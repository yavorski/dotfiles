#!/usr/bin/env bash

# Lambda addition (+)
# * `Œª` - greek small letter lamda
# * `ùù∫` - mathematical sans-serif bold small lamda

# ---------------- Terminal output control ---------------- #
# --------------------------------------------------------- #
# http://www.termsys.demon.co.uk/vtansi.htm

TC='\e['

CLR_LINE_START="${TC}1K"
CLR_LINE_END="${TC}K"
CLR_LINE="${TC}2K"

# Hope no terminal is greater than 1k columns
RESET_LINE="${CLR_LINE}${TC}1000D"

# ---------------- colors & styles ---------------- #
# ------------------------------------------------- #
# https://github.com/demure/dotfiles/blob/master/subbash/prompt

Bold="${TC}1m"    # Bold text only, keep colors
Undr="${TC}4m"    # Underline text only, keep colors
Inv="${TC}7m"     # Inverse: swap background and foreground colors
Reg="${TC}22;24m" # Regular text only, keep colors
RegF="${TC}39m"   # Regular foreground coloring
RegB="${TC}49m"   # Regular background coloring
Rst="${TC}0m"     # Reset all coloring and style

# Basic            High Intensity      Background           High Intensity Background
Black="${TC}30m";  IBlack="${TC}90m";  OnBlack="${TC}40m";  OnIBlack="${TC}100m";
Red="${TC}31m";    IRed="${TC}91m";    OnRed="${TC}41m";    OnIRed="${TC}101m";
Green="${TC}32m";  IGreen="${TC}92m";  OnGreen="${TC}42m";  OnIGreen="${TC}102m";
Yellow="${TC}33m"; IYellow="${TC}93m"; OnYellow="${TC}43m"; OnIYellow="${TC}103m";
Blue="${TC}34m";   IBlue="${TC}94m";   OnBlue="${TC}44m";   OnIBlue="${TC}104m";
Purple="${TC}35m"; IPurple="${TC}95m"; OnPurple="${TC}45m"; OnIPurple="${TC}105m";
Cyan="${TC}36m";   ICyan="${TC}96m";   OnCyan="${TC}46m";   OnICyan="${TC}106m";
White="${TC}37m";  IWhite="${TC}97m";  OnWhite="${TC}47m";  OnIWhite="${TC}107m";

# examples
# echo "${Bold}${Red}bold red on ${OnBlue}blue background,${RegB} now back to regular background, ${RegF}regular foreground and ${Reg}regular text"
# echo "${Bold}${Undr}${Green}You can reset this whole style in one${Rst} command"
# echo -n "${Bold}${Blue}${OnWhite}bold blue text on white background${Rst}"; sleep 3; echo "${RESET_LINE}${Red}${OnYellow}becomes red text on yellow background${Rst}"


# ---------------- git status ---------------- #
# -------------------------------------------- #
# https://github.com/mathiasbynens/dotfiles

prompt_git() {
  local s='';
  local branchName='';

  # Check if the current directory is in a Git repository.
  if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

    # check if the current directory is in .git before running git checks
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

      # Ensure the index is up to date.
      git update-index --really-refresh -q &>/dev/null;

      # Check for uncommitted changes in the index.
      if ! $(git diff --quiet --ignore-submodules --cached); then
        s+='+';
      fi;

      # Check for unstaged changes.
      if ! $(git diff-files --quiet --ignore-submodules --); then
        s+='!';
      fi;

      # Check for untracked files.
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        s+='?';
      fi;

      # Check for stashed files.
      if $(git rev-parse --verify refs/stash &>/dev/null); then
        s+='$';
      fi;

    fi;

    # Get the short symbolic ref.
    # If HEAD isn‚Äôt a symbolic ref, get the short SHA for the latest commit
    # Otherwise, just give up.
    branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
      git rev-parse --short HEAD 2> /dev/null || \
      echo '(unknown)')";

    [ -n "${s}" ] && s=" [${s}]";

    echo -e "${1}${branchName}${2}${s}";
  else
    return;
  fi;
}


# ---------------- PS1 ---------------- #
# ------------------------------------- #
prompt_ps1() {
  # This needs to be first
  local EXIT="$?"

  # Set the terminal title to pwd
  PS1="\[\033]0;\W\007\]";

  # Add exit code, if non 0
  if [[ $EXIT != 0 ]]; then
    PS1+="[${Bold}${Red}${EXIT}${Rst}] ";
  fi

  # Highlight the user name when logged in as root.
  if [[ "${USER}" == "root" ]]; then
    userStyle="${Bold}${Red}"
  else
    userStyle="${Bold}${Cyan}"
  fi

  # Highlight the hostname when connected via SSH.
  if [[ "${SSH_TTY}" ]]; then
    hostStyle="${Bold}${Red}"
  else
    hostStyle="${Yellow}"
  fi

  # if [[ $EXECUTED != 0 ]]; then
  #   PS1+="\n${Rst}"
  # fi

  # user host pwd
  PS1+="${userStyle}\u${Rst} at ${Yellow}\h${Rst} in ${Purple}\w${Rst} "

  # git status
  PS1+="\$(prompt_git ${White}on\ ${Rst}${Red} ${Rst}${Blue})"

  # lambda
  PS1+="\n${Rst}${Bold}ùù∫${Rst} "

  export PS1
}


# ---------------- PS2 ---------------- #
# ------------------------------------- #
prompt_ps2() {
  PS2="\[${yellow}\]‚Üí \[${reset}\]";
  PS2='[\u@\h \w] ‚Üí '
  export PS2;
}


# ---------------- Generate PS1 after cmds ---------------- #
# --------------------------------------------------------- #
export PROMPT_COMMAND=prompt_ps1

